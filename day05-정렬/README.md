# Day5 - 정렬

## 📌버블 정렬 (bubble sort)
- 인접한 데이터의 크기를 비교해 정렬하는 방법
- 비교 대상이 없을 때까지 반복
- 특정한 루프의 전체 영역에서 swap이 한 번도 발생하지 않았다면 그 영역 뒤에 있는 데이터가 모두 정렬됐다는 뜻이므로 프로세스를 종료해도 됨
- 시간복잡도 O(n^2) → 다른 정렬 알고리즘보다 속도가 느린 편 
#### 버블 정렬 과정 (인덱스 예시)
  - 0 ~ 4 까지의 인덱스가 있을경우
  - 0-1 비교 → 1-2 비교 → 2-3 비교 → 3-4 비교 : 4번 인덱스 정렬 완료
  - 0-1 비교 → 1-2 비교 → 2-3 비교 : 3~4번 인덱스 정렬 완료
  - 0-1 비교 → 1-2 비교 : 2~4번 인덱스 정렬 완료
  - 0-1 비교 : 0~4번 인덱스 정렬 완료

## 📌선택 정렬 (selection sort)
- 최솟값 또는 최댓값을 찾아 탐색 구간의 가장 앞쪽 데이터와 swap하여 정렬하는 방법
- 남은 정렬 부분이 없을 때 까지 반복함
- 시간복잡도 O(n^2) 으로 효율적이지 않음
#### 선택 정렬 과정 (인덱스 예시)
  - 9 6 7 3 5 의 데이터가 있을 경우
  - 1회전 : 정렬되지 않은 구간(9 6 7 3 5) 에서 최솟값 탐색 - 최솟값 3을 9데이터와 교환 → **3** 6 7 **9** 5
  - 2회전 : 정렬되지 않은 구간(6 7 9 5) 에서 최솟값 탐색 - 최솟값 5를 6데이터와 교환 → 3 **5** 7 9 **6**
  - 3회전 : 정렬되지 않은 구간(7 9 6) 에서 최솟값 탐색 - 최솟값 6을 7데이터와 교환 → 3 5 **6** 9 **7**
  - 4회전 : 정렬되지 않은 구간(9 7) 에서 최솟값 탐색 - 최솟값 7을 9데이터와 교환 → 3 5 6 **7** **9**
  - 4회전하여 오름차순 완료
    
#### 두 정렬 모두 그 자체를 묻는 코딩 테스트 문제는 잘 나오지 않지만, 이 원리를 응용하는 문제는 나올 수 있으므로 각 정렬이 어떤 원리로 작동하는지 알아두기!